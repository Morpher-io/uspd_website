# Cross-Chain Bridge

USPD is designed to be a versatile stablecoin that operates seamlessly across multiple blockchain networks. While USPD is managing the liquidity on Ethereum mainnet, it is planned that USPD is deployed to most, if not all, other EVM chains as well as non-EVM chains. It should be possible to natively bridge the asset between the chains without sacrificing security.

## Problem Statement

To enhance USPD's utility, it needs to be transferable and usable across multiple blockchain networks (Layer 1s and Layer 2s). This presents several challenges:

1.  **Value Preservation:** USPD is a yield-bearing stablecoin. Its user-facing value (USPD amount) is derived from underlying, non-rebasing `cUSPD` share tokens and a dynamic `yieldFactor` (USPD = `cUSPD` shares * `yieldFactor` / `FACTOR_PRECISION`). This relationship must be maintained or accurately translated across chains.
2.  **Collateral Integrity:** All USPD, regardless of the chain it resides on, is backed by collateral held exclusively on the Ethereum mainnet (L1). The bridging mechanism must ensure that USPD on other chains (L2s) is fully backed by an equivalent value locked on L1.
3.  **Supply Accounting:** The `totalSupply` of USPD on L1 should accurately reflect the total system liability against the L1 collateral. Tokens moved to L2s should be accounted for as locked on L1, not burned, to maintain this clarity.
4.  **Yield Propagation:** The yield generated by the collateral on L1 (which increases the `yieldFactor`) should ideally be reflected in the USPD value on L2s, or at least, the bridging mechanism must account for `yieldFactor` discrepancies between chains at the time of transfer.
5.  **Security:** The bridging process must be secure, minimizing trust assumptions and protecting against exploits that could lead to unbacked USPD or loss of user funds.

## Proposed Solution: Architecture Overview

The proposed solution employs a lock-and-mint mechanism for L1-to-L2 transfers and a burn-and-unlock mechanism for L2-to-L1 transfers. This is facilitated by a set of smart contracts on L1 and corresponding contracts on L2s, with off-chain relayers handling message passing.

### Core Contracts Involved:

*   **`USPDToken.sol` (L1 & L2s):**
    *   The primary user-facing ERC20 token.
    *   On L1, it handles conversions between USPD amounts and `cUSPD` share amounts using the L1 `PoolSharesConversionRate`. It initiates bridging operations by interacting with the `BridgeEscrow` contract.
    *   On L2s, it provides the USPD view over L2 `cUSPD` shares, using the L2 `PoolSharesConversionRate`. It initiates bridging back to L1 by interacting with the L2 `cUSPDToken`.
*   **`cUSPDToken.sol` (L1 & L2s):**
    *   The core, non-rebasing ERC20 share token.
    *   On L1, its shares are transferred to and from the `BridgeEscrow` contract during bridging operations.
    *   On L2s, its shares are minted to users when bridging from L1 and burned when bridging back to L1.
*   **`BridgeEscrow.sol` (L1 only):**
    *   A dedicated contract responsible for holding all `cUSPD` shares locked on L1 that back USPD on L2s.
    *   Tracks the total `cUSPD` shares bridged out and maintains a per-chain accounting of these shares (`bridgedOutSharesPerChain[chainId]`).
*   **`PoolSharesConversionRate.sol` (L1 & L2s):**
    *   Provides the `yieldFactor` used to convert between `cUSPD` shares and USPD amounts.
    *   The L1 instance reflects the true yield from mainnet collateral.
    *   L2 instances must be kept synchronized (or updated at relevant intervals/events) with the L1 `yieldFactor` to ensure accurate USPD value representation on L2s.

### Key Bridging Principle:

The user's intent is always to bridge a specific **USPD value**. This `uspdAmountIntended` by the user, along with the `yieldFactor` of the **source chain at the time of initiating the bridge**, determines a fixed quantity of `cUSPD` shares. This precise `cUSPD` share quantity is what is acted upon (locked on L1, minted on L2, burned on L2, or unlocked on L1) across the bridge. The `sourceYieldFactor` is always included in the cross-chain message to ensure consistent share calculation on the destination chain.

## Bridging Process Detailed

### 1. L1 (Mainnet) to L2 (e.g., Polygon, Arbitrum)

```mermaid
sequenceDiagram
    participant User
    participant BridgeUI as Bridge UI/App
    participant L1_USPDToken as USPDToken (L1)
    participant L1_BridgeEscrow as BridgeEscrow (L1)
    participant L1_cUSPDToken as cUSPDToken (L1)
    participant Relayer as Off-chain Bridge Relayer
    participant L2_BridgeContract as Bridge Contract (L2)
    participant L2_cUSPDToken as cUSPDToken (L2)
    participant L2_PoolSharesRate as PoolSharesConversionRate (L2)

    User->>BridgeUI: Initiate bridge: amount (USPD), targetChainId
    BridgeUI->>L1_USPDToken: lockForBridging(uspdAmountToBridge, targetChainId)
    Note over L1_USPDToken: User must approve cUSPD spend for BridgeEscrow OR USPDToken approves BridgeEscrow
    L1_USPDToken->>L1_USPDToken: Calculate cUSPDShareAmountToLock = (uspdAmountToBridge * FP) / currentL1YieldFactor
    L1_USPDToken->>L1_BridgeEscrow: escrowShares(userAddress, cUSPDShareAmountToLock, targetChainId)
    L1_BridgeEscrow->>L1_cUSPDToken: transferFrom(userAddress, address(this), cUSPDShareAmountToLock)
    L1_BridgeEscrow->>L1_BridgeEscrow: Update totalBridgedOutShares, bridgedOutSharesPerChain
    L1_BridgeEscrow->>Relayer: Emit SharesLockedForBridging(user, targetChainId, shares, uspdAmount, l1YieldFactor)
    
    Relayer->>Relayer: Construct cross-chain message (user, uspdAmountIntended, sourceL1YieldFactor)
    Relayer->>L2_BridgeContract: Submit message to L2
    
    L2_BridgeContract->>L2_BridgeContract: Authenticate message
    L2_BridgeContract->>L2_cUSPDToken: mintForBridging(userAddress, uspdAmountIntended, sourceL1YieldFactor)
    L2_cUSPDToken->>L2_cUSPDToken: Calculate cUSPDSharesToMint = (uspdAmountIntended * FP) / sourceL1YieldFactor
    L2_cUSPDToken->>L2_cUSPDToken: _mint(userAddress, cUSPDSharesToMint)
    L2_cUSPDToken->>Relayer: Emit SharesMintedFromBridge (or similar)
    Note over L2_BridgeContract, L2_PoolSharesRate: L2 PoolSharesConversionRate updated with sourceL1YieldFactor (strategy dependent)
```

**Steps:**

1.  **User Interaction:** The user specifies the `uspdAmountToBridge` and the `targetChainId` through a bridge interface or by interacting with an integrated application.
2.  **L1 `USPDToken.lockForBridging(uspdAmountToBridge, targetChainId)`:**
    *   This function is called on the L1 `USPDToken` contract.
    *   It calculates the `cUSPDShareAmountToLock = (uspdAmountToBridge * FACTOR_PRECISION) / currentL1YieldFactor`. The `currentL1YieldFactor` is fetched from the L1 `PoolSharesConversionRate`.
    *   **Approval:** The user must have pre-approved the L1 `BridgeEscrow` contract to spend their L1 `cUSPD` shares, OR the `USPDToken` contract itself must be approved and then it approves the `BridgeEscrow` to pull the shares. A common pattern is for the user to approve `USPDToken` which then calls `cUSPDToken.transferFrom` on behalf of the user to the `BridgeEscrow`.
    *   It then calls `BridgeEscrow.escrowShares(userAddress, cUSPDShareAmountToLock, targetChainId)`.
3.  **L1 `BridgeEscrow.escrowShares(userAddress, cUSPDShareAmountToLock, targetChainId)`:**
    *   This function on the L1 `BridgeEscrow` contract is responsible for securing the shares.
    *   It executes `cUSPDToken.transferFrom(userAddress, address(this), cUSPDShareAmountToLock)` to pull the calculated `cUSPD` shares from the user into the `BridgeEscrow` contract.
    *   It updates its internal state: increments `totalBridgedOutShares` and `bridgedOutSharesPerChain[targetChainId]` by `cUSPDShareAmountToLock`.
    *   It emits a `SharesLockedForBridging` event containing `userAddress`, `targetChainId`, `cUSPDShareAmountToLock`, the original `uspdAmountToBridge`, and `currentL1YieldFactor`.
4.  **Off-Chain Bridge Relayer:** A relayer service (specific to the chosen bridge provider like Wormhole, LayerZero, etc.) monitors for `SharesLockedForBridging` events on L1.
5.  **Cross-Chain Message to L2:** Upon detecting the event, the relayer constructs and sends a message to the target L2. This message includes:
    *   `recipientAddress` (the user's address on L2).
    *   `uspdAmountIntended` (this is the same as `uspdAmountToBridge` from L1).
    *   `sourceL1YieldFactor` (this is the `currentL1YieldFactor` from L1 at the time of locking).
6.  **L2 Bridge Contract:** A corresponding bridge contract on the L2 receives and authenticates the message from the relayer.
7.  **L2 `cUSPDToken.mintForBridging(recipientAddress, uspdAmountIntended, sourceL1YieldFactor)` (or similar entry point):**
    *   The authenticated L2 bridge contract calls a designated function on the L2 `cUSPDToken` (or L2 `USPDToken`, which then interacts with L2 `cUSPDToken`).
    *   This function calculates `cUSPDShareAmountToMintOnL2 = (uspdAmountIntended * FACTOR_PRECISION) / sourceL1YieldFactor`. Note that it uses the `sourceL1YieldFactor` from the message to ensure the share amount minted on L2 precisely matches the share amount locked on L1 for that transaction.
    *   It mints `cUSPDShareAmountToMintOnL2` to the `recipientAddress` on the L2.
    *   It emits an event like `SharesMintedFromBridge`.
8.  **L2 `PoolSharesConversionRate` Update:** The L2 `PoolSharesConversionRate` contract should be updated with the `sourceL1YieldFactor` received in the message. This ensures that the newly minted `cUSPD` shares on L2 correctly represent the `uspdAmountIntended` value. This update can be part of the `mintForBridging` call or handled by a separate authorized process triggered by the bridge.

### 2. L2 to L1 (Mainnet)

```mermaid
sequenceDiagram
    participant User
    participant BridgeUI as Bridge UI/App
    participant L2_USPDToken as USPDToken (L2)
    participant L2_cUSPDToken as cUSPDToken (L2)
    participant L2_PoolSharesRate as PoolSharesConversionRate (L2)
    participant Relayer as Off-chain Bridge Relayer
    participant L1_BridgeContract as Bridge Contract (L1)
    participant L1_USPDToken as USPDToken (L1)
    participant L1_BridgeEscrow as BridgeEscrow (L1)
    participant L1_cUSPDToken as cUSPDToken (L1)

    User->>BridgeUI: Initiate bridge: amount (USPD), targetChainId (L1)
    BridgeUI->>L2_USPDToken: burnForBridging(uspdAmountToBridge)
    L2_USPDToken->>L2_PoolSharesRate: Get currentL2YieldFactor
    L2_USPDToken->>L2_USPDToken: Calculate cUSPDShareAmountToBurn = (uspdAmountToBridge * FP) / currentL2YieldFactor
    L2_USPDToken->>L2_cUSPDToken: burn(cUSPDShareAmountToBurn)
    Note over L2_cUSPDToken: User must have approved L2_USPDToken OR L2_USPDToken calls executeBurn
    L2_cUSPDToken->>Relayer: Emit SharesBurnedForBridging(user, L1_CHAIN_ID, shares, uspdAmount, l2YieldFactor)
    
    Relayer->>Relayer: Construct cross-chain message (user, uspdAmountIntended, sourceL2YieldFactor, sourceL2ChainId)
    Relayer->>L1_BridgeContract: Submit message to L1
    
    L1_BridgeContract->>L1_BridgeContract: Authenticate message
    L1_BridgeContract->>L1_USPDToken: unlockFromBridging(userAddress, uspdAmountIntended, sourceL2YieldFactor, sourceL2ChainId)
    L1_USPDToken->>L1_USPDToken: Calculate cUSPDShareAmountToUnlock = (uspdAmountIntended * FP) / sourceL2YieldFactor
    L1_USPDToken->>L1_BridgeEscrow: releaseShares(userAddress, cUSPDShareAmountToUnlock, sourceL2ChainId)
    L1_BridgeEscrow->>L1_BridgeEscrow: Verify shares can be released
    L1_BridgeEscrow->>L1_cUSPDToken: transfer(userAddress, cUSPDShareAmountToUnlock)
    L1_BridgeEscrow->>L1_BridgeEscrow: Update totalBridgedOutShares, bridgedOutSharesPerChain
    L1_BridgeEscrow->>Relayer: Emit SharesUnlockedFromBridge (or similar)
```

**Steps:**

1.  **User Interaction:** The user specifies the `uspdAmountToBridge` on the L2 they wish to send back to L1.
2.  **L2 `USPDToken.burnForBridging(uspdAmountToBridge)` (or similar):**
    *   This function is called on the L2 `USPDToken` contract.
    *   It fetches the `currentL2YieldFactor` from the L2 `PoolSharesConversionRate`.
    *   It calculates `cUSPDShareAmountToBurn = (uspdAmountToBridge * FACTOR_PRECISION) / currentL2YieldFactor`.
    *   It then interacts with the L2 `cUSPDToken` to burn `cUSPDShareAmountToBurn` from the user's L2 balance. The user must have approved L2 `USPDToken` to manage their L2 `cUSPD` shares, or `USPDToken` calls a specific burn function on `cUSPDToken`.
    *   An event like `SharesBurnedForBridging` is emitted by L2 `cUSPDToken` (or L2 `USPDToken`) containing `userAddress`, the L1 chain ID, `cUSPDShareAmountToBurn`, the original `uspdAmountToBridge`, and `currentL2YieldFactor`.
3.  **Off-Chain Bridge Relayer:** The relayer monitors for `SharesBurnedForBridging` events on the L2.
4.  **Cross-Chain Message to L1:** The relayer constructs and sends a message to L1. This message includes:
    *   `recipientAddress` (the user's address on L1).
    *   `uspdAmountIntended` (same as `uspdAmountToBridge` from L2).
    *   `sourceL2YieldFactor` (this is the `currentL2YieldFactor` from L2 at the time of burning).
    *   `sourceL2ChainId`.
5.  **L1 Bridge Contract:** A bridge contract on L1 (or an authorized relayer directly) receives and authenticates the message.
6.  **L1 `USPDToken.unlockFromBridging(recipientAddress, uspdAmountIntended, sourceL2YieldFactor, sourceL2ChainId)`:**
    *   The authenticated L1 bridge contract (or relayer) calls this function on the L1 `USPDToken`.
    *   It calculates `cUSPDShareAmountToUnlock = (uspdAmountIntended * FACTOR_PRECISION) / sourceL2YieldFactor`. It uses the `sourceL2YieldFactor` from the message.
    *   It then calls `BridgeEscrow.releaseShares(recipientAddress, cUSPDShareAmountToUnlock, sourceL2ChainId)`.
7.  **L1 `BridgeEscrow.releaseShares(recipientAddress, cUSPDShareAmountToUnlock, sourceL2ChainId)`:**
    *   This function on the L1 `BridgeEscrow` contract handles the release of shares.
    *   It verifies that `cUSPDShareAmountToUnlock` can be released (i.e., `bridgedOutSharesPerChain[sourceL2ChainId]` is sufficient).
    *   It executes `cUSPDToken.transfer(recipientAddress, cUSPDShareAmountToUnlock)` to send the `cUSPD` shares from the `BridgeEscrow` contract back to the user on L1.
    *   It updates its internal state: decrements `totalBridgedOutShares` and `bridgedOutSharesPerChain[sourceL2ChainId]` by `cUSPDShareAmountToUnlock`.
    *   It emits a `SharesUnlockedFromBridge` event.
    *   The user now holds `cUSPDShareAmountToUnlock` on L1. The actual USPD value of these shares is determined by the `currentL1YieldFactor`. If L1 yield has accrued while tokens were on L2, the user effectively receives this accrued yield upon bridging back.

## Yield Factor Synchronization on L2s

The accuracy of USPD value representation on L2s depends on the L2 `PoolSharesConversionRate` reflecting a `yieldFactor` that is reasonably synchronized with L1.
*   **Per-Transaction Update:** Including the `sourceL1YieldFactor` in the bridge message (for L1->L2 transfers) and using it to update the L2 `PoolSharesConversionRate` ensures immediate consistency for that batch of tokens.
*   **Periodic Oracle Update:** Alternatively, or additionally, a trusted oracle mechanism could periodically read the L1 `yieldFactor` and update L2 `PoolSharesConversionRate` contracts. This smooths out the `yieldFactor` on L2s over time.
*   **Lag:** It's acknowledged that L2 `yieldFactor` might slightly lag L1's. However, the core bridging mechanism ensures that the *quantity of shares* is preserved based on the `yieldFactor` at the moment of the bridging transaction initiation.

## Security Considerations

*   **Role-Based Access Control (RBAC):** Sensitive functions (e.g., `escrowShares`, `releaseShares` in `BridgeEscrow`; `mintForBridging` in L2 `cUSPDToken`; `unlockFromBridging` in L1 `USPDToken`; `updateYieldFactor` in L2 `PoolSharesConversionRate`) must be protected by robust RBAC, granting permissions only to authorized bridge contracts or admin/relayer addresses.
*   **Bridge Relayer Security:** The security of the chosen off-chain bridge relayer system is paramount. Compromised relayers could submit fraudulent messages.
*   **Message Authentication:** Cross-chain messages must be rigorously authenticated on the destination chain to prevent spoofing.
*   **Per-Chain Limits:** The `BridgeEscrow` contract's `bridgedOutSharesPerChain` tracking can be extended to enforce maximum limits on the amount of `cUSPD` that can be bridged to any single L2, mitigating the impact of a compromise on one L2.
*   **Reentrancy Guards:** Apply reentrancy guards where appropriate, especially in functions involving external calls and state changes.
*   **Audits:** Thorough independent security audits of all involved smart contracts and the overall bridging architecture are essential.
*   **Emergency Pausability:** Consider pausable mechanisms for critical functions in case of detected vulnerabilities.

## Implementation Plan

This plan outlines the smart contract development and modifications required.

### 1. `BridgeEscrow.sol` (New Contract - L1 Only)

*   **State Variables:**
    *   `IERC20 public immutable cUSPDToken;`
    *   `address public owner;` (or `AccessControl` for admin roles)
    *   `uint256 public totalBridgedOutShares;`
    *   `mapping(uint256 => uint256) public bridgedOutSharesPerChain; // chainId => sharesAmount`
    *   `mapping(address => bool) public authorizedRelayers; // For releaseShares`
    *   `address public uspdTokenAddress; // To verify caller of escrowShares`
*   **Events:**
    *   `event SharesLockedForBridging(address indexed user, uint256 indexed targetChainId, uint256 cUSPDShareAmount, uint256 uspdAmountIntended, uint256 l1YieldFactor);`
    *   `event SharesUnlockedFromBridge(address indexed recipient, uint256 indexed sourceChainId, uint256 cUSPDShareAmount, uint256 uspdAmountIntended, uint256 l2YieldFactor);`
*   **Functions:**
    *   `constructor(address _cUSPDTokenAddress, address _uspdTokenAddress)`
    *   `escrowShares(address user, uint256 cUSPDShareAmount, uint256 targetChainId)`:
        *   `require(msg.sender == uspdTokenAddress, "Caller not USPDToken");`
        *   Requires `cUSPDToken.transferFrom(user, address(this), cUSPDShareAmount)` to succeed.
        *   Updates `totalBridgedOutShares` and `bridgedOutSharesPerChain[targetChainId]`.
        *   Emits `SharesLockedForBridging`.
    *   `releaseShares(address recipient, uint256 cUSPDShareAmount, uint256 sourceChainId)`:
        *   `require(authorizedRelayers[msg.sender], "Caller not authorized relayer");`
        *   Checks `bridgedOutSharesPerChain[sourceChainId] >= cUSPDShareAmount`.
        *   Updates `totalBridgedOutShares` and `bridgedOutSharesPerChain[sourceChainId]`.
        *   `cUSPDToken.transfer(recipient, cUSPDShareAmount)`.
        *   Emits `SharesUnlockedFromBridge`.
    *   **Admin Functions:**
        *   `setUspdTokenAddress(address _uspdTokenAddress)` (onlyOwner)
        *   `setAuthorizedRelayer(address relayer, bool isAuthorized)` (onlyOwner)
        *   `transferOwnership(address newOwner)` (onlyOwner)
        *   Potentially: `setChainLimit(uint256 chainId, uint256 limit)`

### 2. `USPDToken.sol` Modifications (L1)

*   **State Variables:**
    *   `address public bridgeEscrowAddress;`
*   **Events (Consider if new events are needed here or if `BridgeEscrow` events suffice):**
    *   `LockForBridgingInitiated(address indexed user, uint256 targetChainId, uint256 uspdAmount, uint256 cUSPDShareAmount);`
    *   `UnlockFromBridgingInitiated(address indexed recipient, uint256 sourceChainId, uint256 uspdAmountIntended, uint256 sourceL2YieldFactor, uint256 cUSPDShareAmount);`
*   **Functions:**
    *   `lockForBridging(uint256 uspdAmountToBridge, uint256 targetChainId)`:
        *   `require(bridgeEscrowAddress != address(0), "Escrow not set");`
        *   Calculates `cUSPDShareAmount` using L1 `rateContract.getYieldFactor()`.
        *   **Approval Logic:** User needs to have approved `cUSPDToken` spending to `USPDToken` OR `USPDToken` needs to be able to call `cUSPDToken.executeTransferFrom` to move user's shares. Simpler: user approves `BridgeEscrow` directly, or `USPDToken` pulls shares from user to itself, then `USPDToken` approves `BridgeEscrow`. The most direct is for `USPDToken` to orchestrate the `transferFrom` user to `BridgeEscrow`.
        *   Calls `BridgeEscrow(bridgeEscrowAddress).escrowShares(msg.sender, cUSPDShareAmount, targetChainId)`.
        *   Emits `LockForBridgingInitiated` (or rely on `BridgeEscrow` event).
    *   `unlockFromBridging(address recipient, uint256 uspdAmountIntended, uint256 sourceL2YieldFactor, uint256 sourceL2ChainId)`:
        *   `require(bridgeEscrowAddress != address(0), "Escrow not set");`
        *   `require(authorizedRelayers[msg.sender], "Caller not authorized relayer");` (Relayer auth might be on `USPDToken` or `BridgeEscrow`)
        *   Calculates `cUSPDShareAmountToUnlock = (uspdAmountIntended * FACTOR_PRECISION) / sourceL2YieldFactor`.
        *   Calls `BridgeEscrow(bridgeEscrowAddress).releaseShares(recipient, cUSPDShareAmountToUnlock, sourceL2ChainId)`.
        *   Emits `UnlockFromBridgingInitiated` (or rely on `BridgeEscrow` event).
    *   **Admin Functions:**
        *   `setBridgeEscrowAddress(address _bridgeEscrowAddress)` (onlyRole `DEFAULT_ADMIN_ROLE`)
        *   `setAuthorizedRelayer(address relayer, bool isAuthorized)` (onlyRole `DEFAULT_ADMIN_ROLE`)

### 3. `cUSPDToken.sol` Modifications (L2)

*   **State Variables (Consider if specific roles are needed for bridge minters):**
    *   `mapping(address => bool) public authorizedBridgeMinters;`
*   **Events:**
    *   `SharesMintedFromBridge(address indexed recipient, uint256 cUSPDShareAmount, uint256 uspdAmountIntended, uint256 sourceL1YieldFactor);`
*   **Functions:**
    *   `mintForBridging(address recipient, uint256 uspdAmountIntended, uint256 sourceL1YieldFactor)`:
        *   `require(authorizedBridgeMinters[msg.sender], "Caller not bridge minter");`
        *   Calculates `cUSPDShareAmountToMint = (uspdAmountIntended * FACTOR_PRECISION) / sourceL1YieldFactor`.
        *   `_mint(recipient, cUSPDShareAmountToMint)`.
        *   Emits `SharesMintedFromBridge`.
    *   **Admin Functions:**
        *   `setAuthorizedBridgeMinter(address minter, bool isAuthorized)` (onlyRole `DEFAULT_ADMIN_ROLE`)

### 4. `USPDToken.sol` Modifications (L2)

*   **State Variables (Consider if specific roles are needed for bridge burners):**
    *   `address public cUSPDTokenAddress_L2;`
*   **Events:**
    *   `SharesBurnedForBridging(address indexed burner, uint256 targetChainId, uint256 cUSPDShareAmount, uint256 uspdAmountIntended, uint256 l2YieldFactor);`
*   **Functions:**
    *   `burnForBridging(uint256 uspdAmountToBridge)`:
        *   Requires L2 `rateContract` and `cUSPDTokenAddress_L2` to be set.
        *   Calculates `cUSPDShareAmountToBurn` using L2 `rateContract.getYieldFactor()`.
        *   Calls `IcUSPDToken(cUSPDTokenAddress_L2).burn(cUSPDShareAmountToBurn)`. (Requires user to have approved L2 `USPDToken` to burn their L2 `cUSPD` shares, or `USPDToken` calls `executeBurn` on `cUSPDToken`).
        *   Emits `SharesBurnedForBridging`.
    *   **Admin Functions:**
        *   `setCUSPDTokenAddress(address _address)`
        *   `setRateContractAddress(address _address)`

### 5. `PoolSharesConversionRate.sol` Modifications (L2)

*   **Functions:**
    *   `updateYieldFactor(uint256 newYieldFactor)`: (callable by an authorized address, e.g., L2 bridge contract or admin). This function is crucial if the yield factor isn't updated directly by the `mintForBridging` logic.

### 6. Deployment & Configuration Steps:

1.  Deploy L1 `BridgeEscrow` contract, providing L1 `cUSPDToken` address and initial L1 `USPDToken` address.
2.  Call `L1_USPDToken.setBridgeEscrowAddress()` with the deployed `BridgeEscrow` address.
3.  Configure authorized relayers/callers on L1 `BridgeEscrow` and/or L1 `USPDToken`.
4.  Deploy L2 versions of `USPDToken`, `cUSPDToken`, and `PoolSharesConversionRate`.
5.  Configure L2 `USPDToken` with L2 `cUSPDToken` and L2 `PoolSharesConversionRate` addresses.
6.  Configure authorized bridge minters on L2 `cUSPDToken`.
7.  Configure authorized updaters for L2 `PoolSharesConversionRate.updateYieldFactor()` if applicable.

### 7. Off-Chain Components:

*   Develop or integrate bridge relayer services compatible with the chosen cross-chain messaging protocol (e.g., Wormhole, LayerZero, Axelar). These relayers must:
    *   Monitor L1 `BridgeEscrow` for `SharesLockedForBridging` events.
    *   Monitor L2 `USPDToken` (or `cUSPDToken`) for `SharesBurnedForBridging` events.
    *   Securely construct and transmit messages to the destination chain.
*   Develop a user-friendly bridge interface (UI).

This detailed plan should serve as a solid guideline for development and subsequent audits.
Stay tuned for more updates as we progress with the development of this feature.
